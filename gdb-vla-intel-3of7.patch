From d2fd5fea2c06052c53d99bfa25fdaed9cf5dd217 Mon Sep 17 00:00:00 2001
From: Bernhard Heckel <bernhard.heckel@intel.com>
Date: Tue, 12 Jul 2016 08:19:34 +0200
Subject: [PATCH 3/7] Typeprint: Resolve any dynamic target type of a pointer.

Before continuing with language specific type printing
we have to resolve the target type of a pointer
as we might wanna print more details of the target
like the dimension of an array. We have to resolve it here
as we don't have any address information later on.

2016-07-08  Bernhard Heckel  <bernhard.heckel@intel.com>

gdb/Changelog:
	* typeprint.c (whatis_exp): Resolve dynamic target type
	  of pointers.

gdb/Testsuite/Changelog:
	* gdb.cp/vla-cxx.cc: Added pointer to dynamic type.
	* gdb.cp/vla-cxx.exp: Test pointer to dynamic type.

Change-Id: Idff0d6dd0eab3125b45d470a12b5e66b392e42c3
---
 gdb/testsuite/gdb.cp/vla-cxx.cc  |  9 +++++++++
 gdb/testsuite/gdb.cp/vla-cxx.exp |  5 +++++
 gdb/typeprint.c                  | 19 +++++++++++++++++++
 3 files changed, 33 insertions(+)

diff --git a/gdb/testsuite/gdb.cp/vla-cxx.cc b/gdb/testsuite/gdb.cp/vla-cxx.cc
index a1fd510..5f8f8ab 100644
--- a/gdb/testsuite/gdb.cp/vla-cxx.cc
+++ b/gdb/testsuite/gdb.cp/vla-cxx.cc
@@ -15,6 +15,10 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
+extern "C" {
+#include <stddef.h>
+}
+
 struct container;
 
 struct element
@@ -40,11 +44,16 @@ int main(int argc, char **argv)
   typedef typeof (vla) &vlareftypedef;
   vlareftypedef vlaref2 (vla);
   container c;
+  typeof (vla) *ptr = NULL;
+
+  // Before pointer assignment
+  ptr = &vla;
 
   for (int i = 0; i < z; ++i)
     vla[i] = 5 + 2 * i;
 
   // vlas_filled
   vla[0] = 2 * vla[0];
+
   return vla[2];
 }
diff --git a/gdb/testsuite/gdb.cp/vla-cxx.exp b/gdb/testsuite/gdb.cp/vla-cxx.exp
index f6224dc..babdfb7 100644
--- a/gdb/testsuite/gdb.cp/vla-cxx.exp
+++ b/gdb/testsuite/gdb.cp/vla-cxx.exp
@@ -23,6 +23,10 @@ if ![runto_main] {
     return -1
 }
 
+gdb_breakpoint [gdb_get_line_number "Before pointer assignment"]
+gdb_continue_to_breakpoint "Before pointer assignment"
+gdb_test "ptype ptr" "int \\(\\*\\)\\\[variable length\\\]" "ptype ptr, Before pointer assignment"
+
 gdb_breakpoint [gdb_get_line_number "vlas_filled"]
 gdb_continue_to_breakpoint "vlas_filled"
 
@@ -33,3 +37,4 @@ gdb_test "print vlaref" " = \\(int \\(&\\)\\\[3\\\]\\) @$hex: \\{5, 7, 9\\}"
 # bug being tested, it's better not to depend on the exact spelling.
 gdb_test "print vlaref2" " = \\(.*\\) @$hex: \\{5, 7, 9\\}"
 gdb_test "print c" " = \\{e = \\{c = @$hex\\}\\}"
+gdb_test "ptype ptr" "int \\(\\*\\)\\\[3\\\]"
diff --git a/gdb/typeprint.c b/gdb/typeprint.c
index e77513e..e3d84c7 100644
--- a/gdb/typeprint.c
+++ b/gdb/typeprint.c
@@ -485,6 +485,25 @@ whatis_exp (char *exp, int show)
       printf_filtered (" */\n");    
     }
 
+  /* Resolve any dynamic target type, as we might print
+     additional information about the target.
+     For example, in Fortran and C we are printing the dimension of the
+     dynamic array the pointer is pointing to.  */
+  if (TYPE_CODE (type) == TYPE_CODE_PTR
+      && is_dynamic_type (type) == 1)
+    {
+      CORE_ADDR addr;
+      if (NULL != TYPE_DATA_LOCATION (TYPE_TARGET_TYPE(type)))
+	addr = value_address (val);
+      else
+	addr = value_as_address (val);
+
+      if (addr != 0
+	  && type_not_associated (type) == 0)
+	TYPE_TARGET_TYPE (type) = resolve_dynamic_type (TYPE_TARGET_TYPE (type),
+							NULL, addr);
+    }
+
   LA_PRINT_TYPE (type, "", gdb_stdout, show, 0, &flags);
   printf_filtered ("\n");
 
-- 
2.7.4

