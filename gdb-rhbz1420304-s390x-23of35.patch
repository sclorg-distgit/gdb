commit 65d84b76164dc8ec1a1f0f0e0fd41667065ffd4e
Author: Andreas Arnez <arnez@linux.vnet.ibm.com>
Date:   Tue Jun 13 15:20:31 2017 +0200

    Respect piece offset for DW_OP_bit_piece
    
    So far GDB ignores the piece offset of all kinds of DWARF bit
    pieces (DW_OP_bit_piece) and treats such pieces as if the offset was zero.
    
    This is fixed, and an appropriate test is added.
    
    gdb/ChangeLog:
    
            * dwarf2loc.c (read_pieced_value): Respect the piece offset, as
            given by DW_OP_bit_piece.
            (write_pieced_value): Likewise.
    
      Andreas Arnez  <arnez@linux.vnet.ibm.com>
    
            * gdb.dwarf2/var-access.exp: Add test for composite location with
            nonzero piece offsets.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,5 +1,11 @@
 2017-06-13  Andreas Arnez  <arnez@linux.vnet.ibm.com>
 
+	* dwarf2loc.c (read_pieced_value): Respect the piece offset, as
+	given by DW_OP_bit_piece.
+	(write_pieced_value): Likewise.
+
+2017-06-13  Andreas Arnez  <arnez@linux.vnet.ibm.com>
+
 	* dwarf2loc.c (read_pieced_value): Move the buffer allocation and
 	some other preparations to the places where sufficient information
 	is available.
--- a/gdb/dwarf2loc.c
+++ b/gdb/dwarf2loc.c
@@ -1824,11 +1824,14 @@ read_pieced_value (struct value *v)
 	    int optim, unavail;
 
 	    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG
-		&& p->size < reg_bits)
+		&& p->offset + p->size < reg_bits)
 	      {
 		/* Big-endian, and we want less than full size.  */
-		source_offset_bits += reg_bits - p->size;
+		source_offset_bits += reg_bits - (p->offset + p->size);
 	      }
+	    else
+	      source_offset_bits += p->offset;
+
 	    this_size = bits_to_bytes (source_offset_bits, this_size_bits);
 	    buffer.reserve (this_size);
 
@@ -1851,6 +1854,7 @@ read_pieced_value (struct value *v)
 	  break;
 
 	case DWARF_VALUE_MEMORY:
+	  source_offset_bits += p->offset;
 	  this_size = bits_to_bytes (source_offset_bits, this_size_bits);
 	  buffer.reserve (this_size);
 
@@ -1871,12 +1875,15 @@ read_pieced_value (struct value *v)
 	      = 8 * TYPE_LENGTH (value_type (p->v.value));
 
 	    /* Use zeroes if piece reaches beyond stack value.  */
-	    if (p->size > stack_value_size_bits)
+	    if (p->offset + p->size > stack_value_size_bits)
 	      break;
 
 	    /* Piece is anchored at least significant bit end.  */
 	    if (gdbarch_byte_order (objfile_gdbarch) == BFD_ENDIAN_BIG)
-	      source_offset_bits += stack_value_size_bits - p->size;
+	      source_offset_bits += (stack_value_size_bits
+				     - p->offset - p->size);
+	    else
+	      source_offset_bits += p->offset;
 
 	    copy_bitwise (contents, dest_offset_bits,
 			  value_contents_all (p->v.value),
@@ -1891,6 +1898,7 @@ read_pieced_value (struct value *v)
 	    size_t n = this_size_bits;
 
 	    /* Cut off at the end of the implicit value.  */
+	    source_offset_bits += p->offset;
 	    if (source_offset_bits >= literal_size_bits)
 	      break;
 	    if (n > literal_size_bits - source_offset_bits)
@@ -1981,11 +1989,14 @@ write_pieced_value (struct value *to, struct value *from)
 	    ULONGEST reg_bits = 8 * register_size (arch, gdb_regnum);
 
 	    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG
-		&& p->size <= reg_bits)
+		&& p->offset + p->size < reg_bits)
 	      {
 		/* Big-endian, and we want less than full size.  */
-		dest_offset_bits += reg_bits - p->size;
+		dest_offset_bits += reg_bits - (p->offset + p->size);
 	      }
+	    else
+	      dest_offset_bits += p->offset;
+
 	    this_size = bits_to_bytes (dest_offset_bits, this_size_bits);
 	    buffer.reserve (this_size);
 
@@ -2023,6 +2034,8 @@ write_pieced_value (struct value *to, struct value *from)
 	  break;
 	case DWARF_VALUE_MEMORY:
 	  {
+	    dest_offset_bits += p->offset;
+
 	    CORE_ADDR start_addr = p->v.mem.addr + dest_offset_bits / 8;
 
 	    if (dest_offset_bits % 8 == 0 && this_size_bits % 8 == 0
--- a/gdb/testsuite/gdb.dwarf2/var-access.exp
+++ b/gdb/testsuite/gdb.dwarf2/var-access.exp
@@ -228,6 +228,24 @@ Dwarf::assemble $asm_file {
 			piece 1
 		    } SPECIAL_expr}
 		}
+		# One piece per bitfield, using piece offsets: 32 bits of
+		# an implicit value, 9 bits of a stack value, 13 bits of
+		# r0, and 10 bits of buf.
+		DW_TAG_variable {
+		    {name "t3"}
+		    {type :$struct_t_label}
+		    {location {
+			implicit_value 0x12 0x34 0x56 0x78 0x9a
+			bit_piece 32 4
+			const2s -280
+			stack_value
+			bit_piece 9 2
+			regx [lindex $dwarf_regnum 0]
+			bit_piece 13 14
+			addr $buf_var
+			bit_piece 10 42
+		    } SPECIAL_expr}
+		}
 	    }
 	}
     }
@@ -304,3 +322,24 @@ gdb_test_no_output "set var t2.y = 2641"
 gdb_test_no_output "set var t2.z = -400"
 gdb_test_no_output "set var t2.x = 200"
 gdb_test "print t2.x + t2.y + t2.z" " = 2441"
+
+# Bitfield access through pieces with nonzero piece offsets.
+gdb_test_no_output "set var \$[lindex $regname 0] = 0xa8000" \
+    "init reg for t3.y"
+gdb_test_no_output "set var *(char \[2\] *) (a + 5) = { 70, 82 }" \
+    "init mem for t3.z"
+switch $endian {
+    little {set val "u = -1484430527, x = -70, y = 42, z = 145"}
+    big {set val "u = 591751049, x = -70, y = 42, z = 101"}
+}
+gdb_test "print t3" " = \\{$val\\}" \
+    "initialized t3 from reg and mem"
+gdb_test_no_output "set var t3.y = -1" \
+    "overwrite t3.y"
+gdb_test "print/x \$[lindex $regname 0]" " = 0x7ffc000" \
+    "verify t3.y through reg"
+gdb_test_no_output "set var t3.z = -614" \
+    "overwrite t3.z"
+switch $endian {big {set val "0x59, 0xa2"} little {set val "0x6a, 0x56"}}
+gdb_test "print/x *(char \[2\] *) (a + 5)" " = \\{$val\\}" \
+    "verify t3.z through mem"
